<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>NEILWU</title>
  
  <subtitle>neilwu&#39;s time machine</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://neil-wu.github.io/"/>
  <updated>2020-08-31T02:55:31.477Z</updated>
  <id>https://neil-wu.github.io/</id>
  
  <author>
    <name>neilwu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FridaHookSwiftAlamofire</title>
    <link href="https://neil-wu.github.io/2020/07/16/2020-07-16-FridaHookSwiftAlamofire/"/>
    <id>https://neil-wu.github.io/2020/07/16/2020-07-16-FridaHookSwiftAlamofire/</id>
    <published>2020-07-15T16:00:00.000Z</published>
    <updated>2020-08-31T02:55:31.477Z</updated>
    
    <content type="html"><![CDATA[<p>初探Swift Runtime：使用Frida实现针对Alamofire的抓包工具</p><h3 id="0x00-背景"><a href="#0x00-背景" class="headerlink" title="0x00 背景"></a>0x00 背景</h3><p>Swift自2014年发布以来，在Apple的开发生态下占据的位置越来越重要，国外友人在2019年统计过超过半数的非游戏类app已经使用swift，淘宝技术团队曾发文介绍过他们的<a href="https://mp.weixin.qq.com/s/UfOJK07Lhw72dGf0z1znbA" target="_blank" rel="noopener">swift实践</a>。随着swift5在2019年的发布，swift也终于进入ABI稳定，这无疑具有里程碑的意义，相信会有更多的App将离不开swift。</p><p>从逆向的角度看，关于swift的研究分析却较少，一些好项目还由于面向的swift的版本过老而与swift5存在兼容问题无法使用，比如 <a href="https://github.com/maltek/swift-frida" target="_blank" rel="noopener">swift-frida</a>。</p><p>笔者最近粗略学习了一下swift相关的文档，从swift类型在Mach-O文件中的结构入门，逐步到运行时分析。已经实现了一个从Mach-O文件中获取swift对象定义的命令行工具<a href="https://github.com/neil-wu/SwiftDump" target="_blank" rel="noopener">SwiftDump</a>，包括其Frida版本<a href="https://github.com/neil-wu/FridaSwiftDump/" target="_blank" rel="noopener">FridaSwiftDump</a>。</p><p>在本文中，将着重从Swift Runtime数据结构入手进行分析，面向Github上3.3万star的swift HTTP网络库<a href="https://github.com/Alamofire/Alamofire" target="_blank" rel="noopener">Alamofire</a>，实现一个基础版本的抓包工具，具备：打印GET/POST请求；屏蔽SSL Pinning。过程中会介绍到swift的内存布局，函数调用约定，参数传递，运行时函数调用。</p><p><strong>项目地址：<a href="https://github.com/neil-wu/FridaHookSwiftAlamofire" target="_blank" rel="noopener">FridaHookSwiftAlamofire</a></strong></p><a id="more"></a>  <h3 id="0x01-测试环境"><a href="#0x01-测试环境" class="headerlink" title="0x01 测试环境"></a>0x01 测试环境</h3><p>新建空的iOS Swift工程，并使用cocoapods 引用 Alamofire 5.2.1作为framework。<br>使用的Xcode版本为Version 11.5 (11E608c)，swift 5.2，在ARM64的真机下运行。</p><h3 id="0x02-确认关键函数"><a href="#0x02-确认关键函数" class="headerlink" title="0x02 确认关键函数"></a>0x02 确认关键函数</h3><p>我们先从正向的开发环境入手，搞清楚Alamofire的请求过程，挖掘出合适的函数进行Hook。使用Frida完成一个可用的版本后，对其他app进行测试查看实际的使用效果。</p><h4 id="1-Alamofire-Get请求示例"><a href="#1-Alamofire-Get请求示例" class="headerlink" title="1. Alamofire Get请求示例"></a>1. Alamofire Get请求示例</h4><p>发送一个简单的GET请求，测试代码如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Alamofire</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> urlstr = <span class="string">"https://httpbin.org/get?time=\( Int(Date().timeIntervalSince1970) )"</span>;</span><br><span class="line"><span class="type">AF</span>.request(urlstr).response &#123; (rsp:<span class="type">AFDataResponse</span>&lt;<span class="type">Data?</span>&gt;) <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> data = rsp.data &#123;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="type">String</span>(data: data, encoding: <span class="type">String</span>.<span class="type">Encoding</span>.utf8) ?? <span class="string">"nil"</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"rspstr="</span>, str);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> str: <span class="type">String</span> = <span class="string">"faild, err=\(rsp.error?.errorDescription ?? "</span><span class="literal">nil</span><span class="string">")"</span></span><br><span class="line">        <span class="built_in">print</span>(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Alamofire的实现分析"><a href="#2-Alamofire的实现分析" class="headerlink" title="2. Alamofire的实现分析"></a>2. Alamofire的实现分析</h4><p>AF 是 Session.default，<code>Session</code> 是Alamofire中创建和管理<code>Request</code>。<br>调用 AF.request 后， Session会新建一个DataRequest, 并将其加入requestQueue中执行setup过程进行创建。<br>查看DataRequest，在新建出来后，会调用：<br><code>override func task(for request: URLRequest, using session: URLSession) -&gt; URLSessionTask</code><br>熟悉OC的朋友都知道，OC里有个NSURLSessionTask，此处的URLSessionTask正是为了兼容OC而存在的，可以<a href="https://github.com/apple/swift-corelibs-foundation/blob/master/Sources/FoundationNetworking/URLSession/URLSessionTask.swift" target="_blank" rel="noopener">查看其源码</a>。</p><p>既然是与OC兼容，那我们就以Hook OC的方式Hook函数 <code>open func dataTask(with request: URLRequest, completionHandler: @escaping (Data?, URLResponse?, Error?) -&gt; Void) -&gt; URLSessionDataTask</code>。具体实现在 HookDataTaskWithRequest.ts 中，此处比较简单，不再赘述。</p><p>运行Frida Hook，重新发送GET请求，发现确实触发了该Hook，但是completionHandler参数为空。为什么呢？</p><p>继续回到Alamofire源码，看到 Session.swift 的init里可以看到默认URLSession的delegate为SessionDelegate，由其处理请求的各种数据和状态回调。</p><p>找到<code>open func urlSession(_ session: URLSession, dataTask: URLSessionDataTask, didReceive data: Data)</code>，在此函数内接收回包的数据。我们在此进行Hook。这是一个swift函数，并不能用刚才OC的方法进行hook。swift导出的函数在被编译的时候，函数符号名会被name mangle，在swift5下，变为以$开始的一个字符串，其中包含类型信息，比如该函数被修饰为：<br><code>$s9Alamofire15SessionDelegateC03urlB0_8dataTask10didReceiveySo12NSURLSessionC_So0i4DataF0C10Foundation0J0VtF</code> </p><p>我们可以用以下命令来将符号还原（注意$符号前面的\）：</p><p><code>swift demangle &quot;\$s9Alamofire15SessionDelegateC03urlB0_8dataTask10didReceiveySo12NSURLSessionC_So0i4DataF0C10Foundation0J0VtF&quot;</code><br>输出结果为<br><code>Alamofire.SessionDelegate.urlSession(_: __C.NSURLSession, dataTask: __C.NSURLSessionDataTask, didReceive: Foundation.Data) -&gt; ()</code><br>确认是我们需要的函数符号。</p><h3 id="0x03-Foundation-Data的内存布局"><a href="#0x03-Foundation-Data的内存布局" class="headerlink" title="0x03. Foundation.Data的内存布局"></a>0x03. Foundation.Data的内存布局</h3><p>接着以上步骤，在Frida中使用 getExportByName，来获取函数指针并Hook。第一个参数和第二个参数都是兼容OC的类型，可以转为Frida的ObjC.Object类型进行访问。第三个参数为Swift的Foundation.Data类型，怎么获取其数据呢？</p><p>先来研究Foundation.Data，Swift的Foundation库已经<a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">开源</a>，可以一探究竟。找到 <code>Data.swift</code>，将其简化一下，只保留相关定义：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">struct</span> <span class="title">Data</span> : <span class="title">ReferenceConvertible</span>, <span class="title">Equatable</span>, <span class="title">Hashable</span>, <span class="title">RandomAccessCollection</span>, <span class="title">MutableCollection</span>, <span class="title">RangeReplaceableCollection</span>, <span class="title">MutableDataProtocol</span>, <span class="title">ContiguousBytes</span> </span>&#123;</span><br><span class="line">    <span class="comment">// A small inline buffer of bytes suitable for stack-allocation of small data.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">InlineData</span> </span>&#123;<span class="comment">// max=15 bytes</span></span><br><span class="line">        <span class="keyword">var</span> bytes: <span class="type">Buffer</span> <span class="comment">// 15 bytes</span></span><br><span class="line">        <span class="keyword">var</span> length: <span class="type">UInt8</span> <span class="comment">// 1 bytes</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A buffer of bytes too large to fit in an InlineData, but still small enough to fit a storage pointer + range in two words.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">InlineSlice</span> </span>&#123;  <span class="comment">// max=HalfInt.max</span></span><br><span class="line">        <span class="keyword">var</span> slice: <span class="type">Range</span>&lt;<span class="type">HalfInt</span>&gt;</span><br><span class="line">        <span class="keyword">var</span> storage: __DataStorage</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RangeReference</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// A buffer of bytes whose range is too large to fit in a signle word. Used alongside a RangeReference to make it fit into _Representation's two-word size.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LargeSlice</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> slice: <span class="type">RangeReference</span></span><br><span class="line">        <span class="keyword">var</span> storage: __DataStorage</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// The actual storage for Data's various representations.</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="class"><span class="keyword">enum</span> <span class="title">_Representation</span> </span>&#123;</span><br><span class="line">        <span class="keyword">case</span> empty</span><br><span class="line">        <span class="keyword">case</span> inline(<span class="type">InlineData</span>)</span><br><span class="line">        <span class="keyword">case</span> slice(<span class="type">InlineSlice</span>)</span><br><span class="line">        <span class="keyword">case</span> large(<span class="type">LargeSlice</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">var</span> _representation: _Representation</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Underlying storage representation for medium and large data.</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">__DataStorage</span> </span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本结构已知，根据的Data大小不同有不同的表示方式，具体参考上面代码的注释。在arm64环境下，我们的测试请求响应数据大小只有几百bytes，符合InlineSlice。结构如下图所示：</p><p><a href="https://github.com/apple/swift/blob/master/docs/ABI/CallingConvention.rst#id13" target="_blank" rel="noopener">Swift ABI调用约定</a>里有介绍，swift非常注重第一类型，并且能够在寄存器中直接传递类型值。</p><p>在此处的Data类型就用到了这种方法。Data类型的数据被分为两个寄存器来传递：args[2]传递range信息，args[3]传递__DataStorage指针(args[0]指向NSURLSession，args[1]指向NSURLSessionDataTask，函数原型只有三个参数，但实际上调用时会有4个参数)。<br><img src="https://github.com/neil-wu/FridaHookSwiftAlamofire/raw/master/doc/swift_data.jpg" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">args[2] &#x3D; 0x1e000000000 &#x3D;&gt; 0x0,0x1e0 &#x3D;&gt; range from 0 to 0x1e0</span><br><span class="line">args[3] &#x3D; DataStorage&#39;s address</span><br></pre></td></tr></table></figure><p>而__DataStorage是swift class，可以根据<a href="https://github.com/TannerJin/Swift-MemoryLayout/blob/master/Swift/Class.swift" target="_blank" rel="noopener">class memory-layout</a>，解析出对应的地址（参考上面的结构关系图，代码实现在 SDSwiftDataStorage.ts中）。</p><p>注：事实上，我们在正向开发过程中，用Xcode打断点调试，也能看到swift Data的大概结构，如下图：<br><img src="https://github.com/neil-wu/FridaHookSwiftAlamofire/raw/master/doc/af_debug.png" alt=""></p><h3 id="0x04-Kill-SSL-Pinning"><a href="#0x04-Kill-SSL-Pinning" class="headerlink" title="0x04. Kill SSL Pinning"></a>0x04. Kill SSL Pinning</h3><p>先看看Alamofire怎么使用SSL Pinning:</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> manager = <span class="type">ServerTrustManager</span>(evaluators: [<span class="string">"httpbin.org"</span>: <span class="type">PinnedCertificatesTrustEvaluator</span>()])</span><br><span class="line"><span class="keyword">self</span>.session = <span class="type">Session</span>(serverTrustManager: manager)</span><br></pre></td></tr></table></figure><p>跟踪代码，在<code>func attemptServerTrustAuthentication(with challenge: URLAuthenticationChallenge) -&gt; ChallengeEvaluation</code> 里会判断是否需要检查证书，设置了Pinning后会返回useCredential，如果没有设置任何检查项，则返回<code>(.performDefaultHandling, nil, nil)</code>，我们在此只需修改该函数永远返回这个Tuple值。<br>Tuple的memory layout是线性布局的(如果未内存对齐，会为了内存对齐填充0)，用Frida Hook后，指针指向的第一个值就是要修改的值。</p><p>代码在HookAFServerTrust.ts中，如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TypeScript</span></span><br><span class="line"><span class="keyword">let</span> func_attemptServerTrust = Module.getExportByName(<span class="literal">null</span>, <span class="string">'$s9Alamofire15SessionDelegateC32attemptServerTrustAuthentication4withSo36NSURLSessionAuthChallengeDispositionV11disposition_So15NSURLCredentialCSg10credentialAA7AFErrorOSg5errortSo019NSURLAuthenticationK0C_tF'</span>); </span><br><span class="line">log(<span class="string">`[HookAFServerTrust] hook func_attemptServerTrust <span class="subst">$&#123;func_attemptServerTrust&#125;</span>`</span>);</span><br><span class="line">Interceptor.attach(func_attemptServerTrust, &#123;</span><br><span class="line">    onLeave(retval:InvocationReturnValue) &#123;</span><br><span class="line">        <span class="comment">// force set retval to 0x1 to enable .performDefaultHandling</span></span><br><span class="line">        <span class="keyword">let</span> val = retval.toInt32();</span><br><span class="line">        <span class="keyword">if</span> (val != <span class="number">0x1</span>) &#123;</span><br><span class="line">            log(<span class="string">`[HookAFServerTrust] attemptServerTrustAuthentication retval <span class="subst">$&#123;retval&#125;</span>, reset to 0x1`</span>);</span><br><span class="line">            <span class="keyword">let</span> fakeret = <span class="keyword">new</span> NativePointer(<span class="number">0x1</span>)</span><br><span class="line">            retval.replace(fakeret)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="0x05-Swift-String"><a href="#0x05-Swift-String" class="headerlink" title="0x05. Swift String"></a>0x05. Swift String</h3><p>如果我们想获取字符串Swift.String的值，该怎么做呢？<br>查看String的<a href="https://github.com/TannerJin/Swift-MemoryLayout/blob/master/SwiftCore/String.swift" target="_blank" rel="noopener">内存布局</a>。我们可知，String是Struct，值类型，分为 Small(&lt;=15bytes) 和 Large两种表示方式。我们知道Foundation.URL有个函数可以根据String初始化。符号如下：<br><code>s10Foundation3URLV6stringACSgSSh_tcfC ---&gt; Foundation.URL.init(string: __shared Swift.String) -&gt; Foundation.URL?</code>。hook这个函数，笔者发现，对于Small String，Swift会直接使用两个参数来传递该值。对于Large String，是使用两个参数分别指向了两个属性（符合ABI里介绍的调用约定，Swift值类型在传递时特定的情况下会直接用寄存器传递）。具体代码在文件SDSwiftString.ts中。</p><h3 id="0x06-One-More-Step"><a href="#0x06-One-More-Step" class="headerlink" title="0x06. One More Step"></a>0x06. One More Step</h3><p>能否直接调用Swift的运行时函数呢？<br>答案是可以的，但是需要传入合适的参数。<br>举个例子：<br>使用IDA分析我们的测试程序，可以发现<code>$s10Foundation4DataV19_bridgeToObjectiveCSo6NSDataCyF</code> 函数原型为<br><code>Foundation.Data._bridgeToObjectiveC() -&gt; __C.NSData</code><br>它可以将Data类型转为NSData类型，而NSData类型我们是可以直接在Frida下使用的OC类型。参考以上，可以将Data用两个参数传递给这个函数即可，分别表示range和DataStorage。示例代码在 <code>SwiftRuntime.ts</code>中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取函数符号地址</span></span><br><span class="line"><span class="keyword">const</span> func_data2nsdata_ptr = Module.getExportByName(<span class="literal">null</span>, <span class="string">'$s10Foundation4DataV19_bridgeToObjectiveCSo6NSDataCyF'</span>);</span><br><span class="line"><span class="comment">//生成函数指针用于调用</span></span><br><span class="line">funcptr_data_bridgeToObjectiveC = <span class="keyword">new</span> NativeFunction(func_data2nsdata_ptr,<span class="string">'pointer'</span>, [<span class="string">'pointer'</span>, <span class="string">'pointer'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="keyword">let</span> ret:NativePointer = funcptr_data_bridgeToObjectiveC(rangePtr, dataStoragePtr) <span class="keyword">as</span> NativePointer;</span><br><span class="line"><span class="keyword">let</span> ocret = <span class="keyword">new</span> ObjC.Object(ret); <span class="comment">// is __NSSwiftData: NSData</span></span><br><span class="line"><span class="comment">// 接下来可以直接调用OC的函数了，比如： ocret.length() ， ocret.bytes()</span></span><br></pre></td></tr></table></figure><h3 id="0x07-总结"><a href="#0x07-总结" class="headerlink" title="0x07. 总结"></a>0x07. 总结</h3><p>Swift为了与OC兼容，保留了部分动态性，同时，为了更高效的运行，充分利用了寄存器，能直接传递就不间接传递，以实现的复杂性来得到运行的高效性。当然对于逆向研究来说，这里面还有很多可以挖掘的地方，笔者在此仅尝试了一小部分且仍有瑕疵，欢迎大家留言交流学习。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://github.com/apple/swift/blob/master/docs/ABI/CallingConvention.rst" target="_blank" rel="noopener">Swift ABI</a></li><li><a href="https://github.com/apple/swift-corelibs-foundation" target="_blank" rel="noopener">swift-corelibs-foundation</a></li><li><a href="https://github.com/TannerJin/Swift-MemoryLayout" target="_blank" rel="noopener">Swift-MemoryLayout</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;初探Swift Runtime：使用Frida实现针对Alamofire的抓包工具&lt;/p&gt;
&lt;h3 id=&quot;0x00-背景&quot;&gt;&lt;a href=&quot;#0x00-背景&quot; class=&quot;headerlink&quot; title=&quot;0x00 背景&quot;&gt;&lt;/a&gt;0x00 背景&lt;/h3&gt;&lt;p&gt;Swift自2014年发布以来，在Apple的开发生态下占据的位置越来越重要，国外友人在2019年统计过超过半数的非游戏类app已经使用swift，淘宝技术团队曾发文介绍过他们的&lt;a href=&quot;https://mp.weixin.qq.com/s/UfOJK07Lhw72dGf0z1znbA&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;swift实践&lt;/a&gt;。随着swift5在2019年的发布，swift也终于进入ABI稳定，这无疑具有里程碑的意义，相信会有更多的App将离不开swift。&lt;/p&gt;
&lt;p&gt;从逆向的角度看，关于swift的研究分析却较少，一些好项目还由于面向的swift的版本过老而与swift5存在兼容问题无法使用，比如 &lt;a href=&quot;https://github.com/maltek/swift-frida&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;swift-frida&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;笔者最近粗略学习了一下swift相关的文档，从swift类型在Mach-O文件中的结构入门，逐步到运行时分析。已经实现了一个从Mach-O文件中获取swift对象定义的命令行工具&lt;a href=&quot;https://github.com/neil-wu/SwiftDump&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SwiftDump&lt;/a&gt;，包括其Frida版本&lt;a href=&quot;https://github.com/neil-wu/FridaSwiftDump/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FridaSwiftDump&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;在本文中，将着重从Swift Runtime数据结构入手进行分析，面向Github上3.3万star的swift HTTP网络库&lt;a href=&quot;https://github.com/Alamofire/Alamofire&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Alamofire&lt;/a&gt;，实现一个基础版本的抓包工具，具备：打印GET/POST请求；屏蔽SSL Pinning。过程中会介绍到swift的内存布局，函数调用约定，参数传递，运行时函数调用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;项目地址：&lt;a href=&quot;https://github.com/neil-wu/FridaHookSwiftAlamofire&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FridaHookSwiftAlamofire&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="技术" scheme="https://neil-wu.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS逆向" scheme="https://neil-wu.github.io/tags/iOS%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>SwiftDump</title>
    <link href="https://neil-wu.github.io/2020/07/05/2020-07-05-SwiftDump/"/>
    <id>https://neil-wu.github.io/2020/07/05/2020-07-05-SwiftDump/</id>
    <published>2020-07-04T16:00:00.000Z</published>
    <updated>2020-08-31T02:55:48.087Z</updated>
    
    <content type="html"><![CDATA[<h4 id="SwiftDump"><a href="#SwiftDump" class="headerlink" title="SwiftDump"></a>SwiftDump</h4><p><a href="https://github.com/neil-wu/SwiftDump" target="_blank" rel="noopener">https://github.com/neil-wu/SwiftDump</a></p><h5 id="中文文档"><a href="#中文文档" class="headerlink" title="中文文档"></a><a href="https://github.com/neil-wu/SwiftDump/blob/master/README_zh.md" target="_blank" rel="noopener">中文文档</a></h5><p>SwiftDump is a command-line tool for retriving the Swift Object info from Mach-O file. Similar to <a href="https://github.com/nygard/class-dump/" target="_blank" rel="noopener">class-dump</a>, but the difference is that SwiftDump focus on swift 5 objects. For Mach-O files mixed with Objective-C and swift, you can combine class-dump with SwiftDump.</p><p>There is alos a <a href="https://www.frida.re/" target="_blank" rel="noopener">Frida</a> version named <a href="https://github.com/neil-wu/FridaSwiftDump/" target="_blank" rel="noopener">FridaSwiftDump</a>.</p><a id="more"></a>  <p>You can either use<code>SwiftDump</code> for a Mach-O file or <code>FridaSwiftDump</code> for a foreground running app.</p><p>If you are curious about the Mach-O format, check the image at the bottom of this article.</p><p><img src="https://github.com/neil-wu/SwiftDump/blob/master/Doc/img_demo_result.jpg?raw=true" alt="demo"></p><h4 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">USAGE: SwiftDump [--debug] [--arch &lt;arch&gt;] &lt;file&gt; [--version]</span><br><span class="line"></span><br><span class="line">ARGUMENTS:</span><br><span class="line">  &lt;file&gt;                  MachO File</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">  -d, --debug             Show debug log.</span><br><span class="line">  -a, --arch &lt;arch&gt;       Choose architecture from a fat binary (only support x86_64&#x2F;arm64).</span><br><span class="line">                          (default: arm64)</span><br><span class="line">  -v, --version           Version</span><br><span class="line">  -h, --help              Show help information.</span><br></pre></td></tr></table></figure><ul><li>SwiftDump ./TestMachO &gt; result.txt</li><li>SwiftDump -a x86_64 ./TestMachO &gt; result.txt</li></ul><h4 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h4><ul><li>Written entirely in swift, the project is tiny</li><li>Dump swift 5 struct/class/enum/protocol</li><li>Parse enum with payload case</li><li>Support inheritance and protocol</li><li>Since it is written in swift, the mangled names are demangled by swift’s runtime function, such as <code>swift_getTypeByMangledNameInContext</code> and <code>swift_demangle_getDemangledName</code>. </li></ul><p>Thanks to the runtime function, SwiftDump can demangle complex type, such as RxSwift variable. For example,<br><code>RxSwift.Queue&lt;(eventTime: Foundation.Date, event: RxSwift.Event&lt;A.RxSwift.ObserverType.Element&gt;)&gt;</code></p><h4 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h4><ul><li>Parse swift function address</li><li>More</li></ul><h4 id="Compile"><a href="#Compile" class="headerlink" title="Compile"></a>Compile</h4><ol><li>Clone the repo</li><li>Open SwiftDump.xcodeproj with Xcode</li><li>Modify ‘Signing &amp; Capabilities’ to use your own id</li><li>Build &amp; Run</li></ol><p>The default Mach-O file path is <code>Demo/test</code>, you can change it in <code>Xcode - Product - Scheme - Edit Scheme - Arguments</code></p><p>(Tested on Xcode Version 11.5 (11E608c), MacOS 10.15.5)</p><h4 id="Credit"><a href="#Credit" class="headerlink" title="Credit"></a>Credit</h4><ul><li><a href="https://github.com/g-Off/Machismo" target="_blank" rel="noopener">Machismo</a> : Parsing of Mach-O binaries using swift.</li><li><a href="https://github.com/apple/swift-argument-parser" target="_blank" rel="noopener">swift-argument-parser</a> : Straightforward, type-safe argument parsing for Swift.</li><li><a href="https://knight.sc/reverse%20engineering/2019/07/17/swift-metadata.html" target="_blank" rel="noopener">Swift metadata</a> : High level description of all the Swift 5 sections that can show up in a Swift binary.</li></ul><h4 id="License"><a href="#License" class="headerlink" title="License"></a>License</h4><p>MIT</p><h4 id="Mach-O-File-Format"><a href="#Mach-O-File-Format" class="headerlink" title="Mach-O File Format"></a>Mach-O File Format</h4><p>The following image shows how SwiftDump parse swift types from file <code>Demo/test</code>. You can open this file with <a href="https://github.com/gdbinit/MachOView" target="_blank" rel="noopener">MachOView</a>.</p><p><img src="https://github.com/neil-wu/SwiftDump/blob/master/Doc/macho.jpg?raw=true" alt="demo"></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;SwiftDump&quot;&gt;&lt;a href=&quot;#SwiftDump&quot; class=&quot;headerlink&quot; title=&quot;SwiftDump&quot;&gt;&lt;/a&gt;SwiftDump&lt;/h4&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/neil-wu/SwiftDump&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/neil-wu/SwiftDump&lt;/a&gt;&lt;/p&gt;
&lt;h5 id=&quot;中文文档&quot;&gt;&lt;a href=&quot;#中文文档&quot; class=&quot;headerlink&quot; title=&quot;中文文档&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://github.com/neil-wu/SwiftDump/blob/master/README_zh.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;中文文档&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;SwiftDump is a command-line tool for retriving the Swift Object info from Mach-O file. Similar to &lt;a href=&quot;https://github.com/nygard/class-dump/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;class-dump&lt;/a&gt;, but the difference is that SwiftDump focus on swift 5 objects. For Mach-O files mixed with Objective-C and swift, you can combine class-dump with SwiftDump.&lt;/p&gt;
&lt;p&gt;There is alos a &lt;a href=&quot;https://www.frida.re/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Frida&lt;/a&gt; version named &lt;a href=&quot;https://github.com/neil-wu/FridaSwiftDump/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FridaSwiftDump&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="技术" scheme="https://neil-wu.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS逆向" scheme="https://neil-wu.github.io/tags/iOS%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>谁动了我的宽带？记一次HTTP劫持的发现过程</title>
    <link href="https://neil-wu.github.io/2020/04/06/2020-04-06-wan-hijack/"/>
    <id>https://neil-wu.github.io/2020/04/06/2020-04-06-wan-hijack/</id>
    <published>2020-04-06T06:07:43.000Z</published>
    <updated>2020-08-29T02:31:03.744Z</updated>
    
    <content type="html"><![CDATA[<p>日常遇到的劫持一般为DNS劫持，可在路由器里强制指定公共DNS解决。本文记录了自己家用宽带HTTP劫持的发现过程。相比DNS劫持，HTTP劫持更为流氓，解决起来也比较棘手。</p><a id="more"></a> <p>近来在家上网时，iPhone Safari网页里经常弹出“在手机淘宝中打开连接吗？”的提示框，如下图：</p><figure>    <img src="/images/article/wanhijack/hijack.png" style="width:200px;"/></figure>作为一名iOS码农，很自然的知道这是网页在调用淘宝app的 URL Scheme tbopen:// ，这是干什么的呢？当然是淘宝客的推广链接，点了之后打开淘宝去领券，如果你按提示下单了，推广者就能拿到返利。问题在于，网页为什么会发出这种请求，结合当前网站是http的，隐隐觉得可能是被劫持了。下面记录一下排查过程。<h3 id="谁在劫持"><a href="#谁在劫持" class="headerlink" title="谁在劫持"></a>谁在劫持</h3><p>先说一下环境，家里宽带是联通百兆，路由器华硕AC86U,刷的梅林（仅开启虚拟内存插件），路由器直接拨号，且当时安装条件限制，家里没有光猫，接线员直接接到了一楼的交换机上。</p><ol><li><p>是网站自己挂的广告吗？<br>在Wi-Fi下，每次用Safari隐身模式反复访问截图里这个网站，仍会出现这个提示，概率大概30%-40%。切换手机联通4G网络，移动4G，则一次都不会出现。换用电脑Safari和Chrome，也一次不会出现。<br>结论：仅在iPhone手机端Wi-Fi环境才会出现</p></li><li><p>是路由器刷的梅林固件导致的吗？<br>翻箱倒柜找出了以前买的 TPLink-WR700n，就是下图这个小路由器（简直是神器，小巧玲珑，AP和Router模式任意切换），设置好拨号账号密码后换掉华硕继续测试，震惊了，劫持弹窗仍然存在。</p><figure> <img src="/images/article/wanhijack/wr700n.png" style="width:200px;"/></figure>结论：梅林没问题，只能是运营商的锅了。</li></ol><h3 id="怎样劫持"><a href="#怎样劫持" class="headerlink" title="怎样劫持"></a>怎样劫持</h3><p>由于梅林里已经设置DNS为114，排除了DNS劫持。确定是运营商的接入点的问题，接下来就是看看它究竟是怎么劫持的。这里使用Charles抓包iPhone（还没必要祭出Wireshark大杀器）具体设置不在这里讲了，在百度里随机访问网页，待出现劫持时，停止记录，开始分析记录日志。从后往前，找出返回数据里包含 tbopen 的请求。不出意外，很容易就发现了：</p><figure>    <img src="/images/article/wanhijack/charles.png"/></figure><p>原请求为 <code>http://static.geetest.com/static/js/fullpage.8.9.3.js</code> ，经过确认，<code>https://www.geetest.com/</code>极验，是业界提供安全与风控解决方案的平台，不可能返回 tbopen 这样的数据的。在Charles里复制此http请求的curl命令出来，使用阿里云VPS里进行访问，获取到的则为真实的JS内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H &#39;Host: static.geetest.com&#39; -H &#39;Accept: *&#x2F;*&#39; -H &#39;User-Agent: Mozilla&#x2F;5.0 (iPhone; CPU iPhone OS 12_1_3 like Mac OS X) AppleWebKit&#x2F;605.1.15 (KHTML, like Gecko) Version&#x2F;12.0 Mobile&#x2F;15E148 Safari&#x2F;604.1&#39; -H &#39;Accept-Language: zh-cn&#39; -H &#39;Referer: http:&#x2F;&#x2F;pass.52pk.com&#x2F;&#39; --compressed &#39;http:&#x2F;&#x2F;static.geetest.com&#x2F;static&#x2F;js&#x2F;fullpage.8.9.3.js&#39;</span><br></pre></td></tr></table></figure><p>使用自己的Mac重放这个curl命令，还是有很高几率被劫持。进一步，修改此请求的User-Agent字段，去掉手机标识符，仅保留为Safari，继续重放，则不会出现被劫持。同时，注意到发生劫持后，有个新的同样的js请求发出，url里多了个参数 <code>utm_id=1024001</code>，会返回正确的JS内容，这样做的目的，猜测可能是为了区分请求，好让真正的JS能正常返回不影响网页加载，否则可能出现劫持后再被劫持，无法加载出正确的JS内容。</p><p><code>至此，整个劫持的过程大致清晰了：联通的接入点会根据UA过滤出移动设备中的http JS请求，然后一定几率返回劫持后的伪JS内容，在里面嵌入淘宝客推广链接。</code></p><p>劫持的JS内容如下，里面有淘宝客推广链接，建议阿里妈妈的相关人士解决一下？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> u = <span class="string">"http://static.geetest.com/static/js/fullpage.8.9.3.js"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadjs</span>(<span class="params">a, cla</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="built_in">document</span>.createElement(<span class="string">"script"</span>);</span><br><span class="line">    c.setAttribute(<span class="string">"type"</span>, <span class="string">"text/javascript"</span>);</span><br><span class="line">    c.setAttribute(<span class="string">"src"</span>, a);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> cla === <span class="string">"string"</span>) &#123;</span><br><span class="line">        c.setAttribute(<span class="string">"class"</span>, cla)</span><br><span class="line">    &#125;</span><br><span class="line">    c.setAttribute(<span class="string">"charset"</span>, <span class="string">"utf-8"</span>);</span><br><span class="line">    c.setAttribute(<span class="string">"id"</span>, <span class="string">"r_script"</span>);</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(c)</span><br><span class="line">&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> __event != <span class="string">"undefined"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> jsondata = &#123;</span><br><span class="line">        dd: <span class="built_in">document</span>,</span><br><span class="line">        _appurl: <span class="string">"tbopen://m.taobao.com/tbopen/index.html?source=auto&amp;action=ali.open.nav&amp;module=h5&amp;bootImage=0&amp;spm=2014.ugdhh.2200803433966.219351-5751-32768&amp;bc_fl_src=growth_dhh_2200803433966_219351-5751-32768&amp;materialid=219351&amp;h5Url=https%3A%2F%2Fh5.m.taobao.com%2Fbcec%2Fdahanghai-jump.html%3Fspm%3D2014.ugdhh.2200803433966.219351-5751-32768%26bc_fl_src%3Dgrowth_dhh_2200803433966_219351-5751-32768"</span>,</span><br><span class="line">        Initevent: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> a = <span class="keyword">this</span>;</span><br><span class="line">            a.dd = h.document</span><br><span class="line">        &#125;,</span><br><span class="line">        openApp: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> c = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">var</span> lk = c.dd.createElement(<span class="string">"a"</span>);</span><br><span class="line">            c.dd.body.appendChild(lk);</span><br><span class="line">            lk.setAttribute(<span class="string">'href'</span>, c._appurl);</span><br><span class="line">            lk.style.display = <span class="string">'none'</span>;</span><br><span class="line">            lk.click()</span><br><span class="line">        &#125;,</span><br><span class="line">        Start: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> c = <span class="keyword">this</span>;</span><br><span class="line">            c.Initevent();</span><br><span class="line">            <span class="keyword">var</span> intHandle = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (c.dd.body != <span class="literal">null</span>) &#123;</span><br><span class="line">                    clearInterval(intHandle);</span><br><span class="line">                    c.openApp()</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">20</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    h.__event = jsondata;</span><br><span class="line">    jsondata.Start()</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br><span class="line"><span class="keyword">if</span> (u.indexOf(<span class="string">"?"</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    u += <span class="string">"&amp;utm_id=1024001"</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    u += <span class="string">"?utm_id=1024001"</span></span><br><span class="line">&#125;</span><br><span class="line">loadjs(u);</span><br></pre></td></tr></table></figure><p>代码比较简单，将自己的JS脚本挂载到页面DOM上，使用setInterval延迟20ms去调用tbopen，打开淘宝app领券。<br>想在手机端暂时屏蔽的话，可以在surge里加个Header Rewrite规则修改UA</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[Header Rewrite]</span><br><span class="line">^http:&#x2F;&#x2F;* header-replace User-Agent Safari&#x2F;530</span><br></pre></td></tr></table></figure><h3 id="维权投诉"><a href="#维权投诉" class="headerlink" title="维权投诉"></a>维权投诉</h3><p>用手机录屏两段视频作为证据，先打联通客服投诉电话，客服按套路说会派人来检查。一天过后回电说检修人员说是客户家里问题，无法解决。 ？？？根本没人联系我，且上门检查。没关系，心平气和的告诉客服小妹，你们解决不了那俺只能向上投诉了。这里不用跟客服急眼，先向运营商投诉本来也不指望他们能马上解决，该走的流程还是得走一下。找到省通信管理局网站，留言说明了情况，第二天临下班前就有回访电话，把自己录的视频作为证据都发过去，没多久运营商回电说安排人带路由器检查确定问题。检查的小哥没多久也回电了解情况，先问是否重设了DNS为114，（梅林早已设置过），无解后约了个时间说来检查。约定的检查日期来了，我不停的重试测试，还是会被劫持，早上10:30左右，路由器记录到网络重连，之后再测试，再也没出现过劫持，然而检查人员也并未登门检查，看来是悄悄把接入点给改了。至此，一场没有结局的投诉就这样不明不白的解决了。</p><h3 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h3><p>整个过程中，面对网络运营商，用户人微言轻，举证困难，运营商可以随时修改设置关闭劫持。通管局指定运营商自查，并不是指定第三方来审查。运营商“我查我自己”，究竟是内部个别员工作祟还是自身作祟，也不得而知。网络安全服务提供商极验，对自己提供的服务未采用https协议传输，在这两年风风火火的全民https时代，显得尤为落后，更何况自身提供的就是反欺诈等服务，到头来反而自身服务被劫持，作为受害者兼背锅侠，也是冤枉。</p><p>最后的最后，站长们还没上https的赶快上吧。</p><p>(完)<br>(原创文章，转载请注明出处)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;日常遇到的劫持一般为DNS劫持，可在路由器里强制指定公共DNS解决。本文记录了自己家用宽带HTTP劫持的发现过程。相比DNS劫持，HTTP劫持更为流氓，解决起来也比较棘手。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="net" scheme="https://neil-wu.github.io/tags/net/"/>
    
  </entry>
  
  <entry>
    <title>更新SSH key为Ed25519</title>
    <link href="https://neil-wu.github.io/2020/04/04/2020-04-04-SSH-key/"/>
    <id>https://neil-wu.github.io/2020/04/04/2020-04-04-SSH-key/</id>
    <published>2020-04-04T13:32:57.000Z</published>
    <updated>2020-08-29T02:31:03.743Z</updated>
    
    <content type="html"><![CDATA[<p>SSH key对于开发者来说并不陌生，不管是远程登录还是git提交代码，SSH key与使用账号密码相比，更加安全便捷。本文介绍目前最新的key格式 Ed25519。</p><a id="more"></a>  <h3 id="SSH常见key格式"><a href="#SSH常见key格式" class="headerlink" title="SSH常见key格式"></a>SSH常见key格式</h3><ul><li>DSA 它是不安全的，OpenSSL从v7版本开始已放弃对其支持，如果你正在使用，请马上升级。</li><li>RSA 安全性依赖于key的大小，3072位或4096位的key是安全的，小于此大小的key可能需要升级一下，1024位的key已经被认为不安全。</li><li>ECDSA 安全性取决于你的计算机生成随机数的能力，该随机数将用于创建签名，ECDSA使用的NIST曲线也存在可信赖性问题。</li><li>Ed25519 是目前最推荐的公钥算法。</li></ul><h3 id="Ed25519的优势"><a href="#Ed25519的优势" class="headerlink" title="Ed25519的优势"></a>Ed25519的优势</h3><p>OpenSSL 从6.5版本引入Ed25519，是使用Twisted Edwards curve的EdDSA实现。与DSA或ECDSA相比，它使用的是椭圆曲线加密技术可提供更好的安全性和性能。</p><p>RSA是目前使用最广泛的SSH key格式，但同Ed25519相比，RSA速度更慢，且当key小于2048位时是不安全的。</p><p>Ed25519公钥更为紧凑，仅68个字符。生成密钥和签名的过程都非常快，使用Ed25519进行批量签名验证也很快。它是为防碰撞而设计的，防哈希冲突。</p><h3 id="生成Ed25519密钥"><a href="#生成Ed25519密钥" class="headerlink" title="生成Ed25519密钥"></a>生成Ed25519密钥</h3><p><code>ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519 -C &quot;john@example.com&quot;</code></p><p>参数说明：</p><ul><li>-o : 使用新的OpenSSH格式来存储私钥，当使用ed25519格式时，默认会启用此选项</li><li>-a : 进行几轮KDF。值越大则密码验证越慢，也能更好的抗暴力破解。</li><li>-t : 创建的key的类型，我们使用ed25519</li><li>-f : 生成的文件名</li><li>-C : 可选注释，通常写自己的邮箱</li></ul><p>生成好后，就可以像以往一样使用了。</p><p>对于macOS用户，为了自动使用key并且把密码保存在keychain中，需要额外的设置 <code>~/.ssh/config</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">  AddKeysToAgent yes</span><br><span class="line">  UseKeychain yes</span><br><span class="line">  IdentityFile ~&#x2F;.ssh&#x2F;id_ed25519</span><br><span class="line">  IdentityFile ~&#x2F;.ssh&#x2F;id_rsa # Keep any old key files if you want</span><br></pre></td></tr></table></figure><p>然后将私钥添加到ssh agent：<br><code>ssh-add -K ~/.ssh/id_ed25519</code></p><p>也可以在ssh的时候自定义使用哪个key,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host awesome</span><br><span class="line">  HostName 198.222.111.33</span><br><span class="line">  User john</span><br><span class="line">  IdentityFile ~&#x2F;.ssh&#x2F;id_ed25519</span><br><span class="line">  IdentitiesOnly yes</span><br></pre></td></tr></table></figure><p>然后使用 ssh awesome 即可登录。</p><p>(完)<br>(原创文章，转载请注明出处)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;SSH key对于开发者来说并不陌生，不管是远程登录还是git提交代码，SSH key与使用账号密码相比，更加安全便捷。本文介绍目前最新的key格式 Ed25519。&lt;/p&gt;
    
    </summary>
    
    
    
      <category term="tech" scheme="https://neil-wu.github.io/tags/tech/"/>
    
  </entry>
  
  <entry>
    <title>FridaNSLogger</title>
    <link href="https://neil-wu.github.io/2020/01/14/2020-01-14-FridaNSLogger/"/>
    <id>https://neil-wu.github.io/2020/01/14/2020-01-14-FridaNSLogger/</id>
    <published>2020-01-13T16:00:00.000Z</published>
    <updated>2020-04-04T12:34:16.201Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FridaNSLogger"><a href="#FridaNSLogger" class="headerlink" title="FridaNSLogger"></a>FridaNSLogger</h2><p>FridaNSLogger可以在Frida中将日志信息通过socket连接发送至Mac端查看。<br>Mac端日志查看工具 <code>FridaNSLoggerViewer</code> 基于 <a href="https://github.com/fpillet/NSLogger" target="_blank" rel="noopener">NSLogger</a> 修改实现。<br>项目地址 <a href="https://github.com/neil-wu/FridaNSLogger" target="_blank" rel="noopener">https://github.com/neil-wu/FridaNSLogger</a></p><a id="more"></a>  <h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>可以在Frida TypeScript代码中直接发送日志消息；</li><li>支持 string 和 binary 类型日志消息；</li><li>支持简单的断线重连；</li><li>完备的Mac端日志查看器FridaNSLoggerViewer（支持日志分级，过滤，保存等）；</li></ul><h3 id="快速使用"><a href="#快速使用" class="headerlink" title="快速使用"></a>快速使用</h3><ol><li><p>在Mac端启动日志查看器FridaNSLoggerViewer，默认监听 127.0.0.1:50010 ，并获取该Mac系统内网IP(比如192.168.2.10)</p></li><li><p>在Frida TypeScript工程中引用：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Logger &#125; <span class="keyword">from</span> <span class="string">"./logger"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; swapInt64 &#125; <span class="keyword">from</span> <span class="string">"./logger"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接到局域网内的FridaNSLoggerViewer，注意修改IP。</span></span><br><span class="line"><span class="comment">// 如果Frida脚本</span></span><br><span class="line"><span class="keyword">const</span> logger = <span class="keyword">new</span> Logger(<span class="string">'192.168.2.10'</span>, <span class="number">50010</span>);</span><br><span class="line">logger.logStr(<span class="string">'helloworld'</span>); <span class="comment">//发送string类型日志</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> testS64 = <span class="keyword">new</span> Int64(<span class="string">'0x0102030405060708'</span>);</span><br><span class="line"><span class="keyword">const</span> testBuf = Memory.alloc(<span class="number">8</span>).writeS64( swapInt64(testS64) ).readByteArray(<span class="number">8</span>);</span><br><span class="line">logger.logBinary(testBuf <span class="keyword">as</span> <span class="built_in">ArrayBuffer</span>); <span class="comment">//发送binary类型日志</span></span><br></pre></td></tr></table></figure></li></ol><p>FridaNSLoggerViewer 效果如下图：</p><figure>    <img src="/images/article/FridaNSLoggerViewer.png"/></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>Frida脚本内作为client，利用Frida的 SocketConnection 接口，将日志编码后发送；<br>FridaNSLoggerViewer作为socket服务端，可监听局域网内多个client发来的连接。NSLogger原有实现需要加密后的socket数据，FridaNSLoggerViewer对其修改，去掉了加密，支持 raw tcp packet.</p><p>新加入的client默认第一条消息发送设备信息，包含Frida版本，系统版本等信息。后续每条日志打包为一个LogMessage发送。</p><p>NSLogger接收的单个二进制数据包格式为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span>    totalSize        <span class="comment">//(total size for the whole message excluding this 4-byte count)</span></span><br><span class="line"><span class="keyword">uint16_t</span>    partCount        <span class="comment">//(number of parts below)</span></span><br><span class="line">[repeat partCount times]:</span><br><span class="line">    <span class="keyword">uint8_t</span>        partKey        <span class="comment">//the part key</span></span><br><span class="line">    <span class="keyword">uint8_t</span>        partType    <span class="comment">//(string, binary, image, int16, int32, int64)</span></span><br><span class="line">    <span class="keyword">uint32_t</span>    partSize    <span class="comment">//(only for string, binary and image types, others are implicit)</span></span><br><span class="line">    .. `partSize<span class="number">'</span> data bytes</span><br></pre></td></tr></table></figure><p>举例：<br>一个LogMessage的数据包拆分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">00000073 &#x2F;&#x2F;totalSize，占4byte。数值为整个包的字节数减去4，即后续部分长度</span><br><span class="line">000a &#x2F;&#x2F;0xa&#x3D;10 parts，2byte，有多少个parts</span><br><span class="line">0104 00000000 5e13fedb &#x2F;&#x2F;01&#x3D;PART_KEY_TIMESTAMP_S, 04&#x3D;PART_TYPE_INT64</span><br><span class="line">0304 00000000 00011402 &#x2F;&#x2F;03&#x3D;PART_KEY_TIMESTAMP_US</span><br><span class="line">0400 00000008 54687265 61642036  &#x2F;&#x2F;PART_KEY_THREAD_ID   </span><br><span class="line">0003 00000003 &#x2F;&#x2F; PART_KEY_MESSAGE_TYPE  PART_TYPE_INT32 </span><br><span class="line">1500 00000001 31 &#x2F;&#x2F;0x15&#x3D;21,PART_KEY_CLIENT_VERSION</span><br><span class="line">1400 0000000f 4e534c6f 67676572 54657374 417070 &#x2F;&#x2F; 0x14&#x3D;20,PART_KEY_CLIENT_NAME </span><br><span class="line">1900 00000008 6950686f 6e652058 &#x2F;&#x2F;0x19&#x3D;25&#x3D;PART_KEY_UNIQUEID</span><br><span class="line">1700 00000004 31322e32 &#x2F;&#x2F;0x17&#x3D;23&#x3D;PART_KEY_OS_VERSION</span><br><span class="line">1600 00000003 694f53 &#x2F;&#x2F;0x16&#x3D;22&#x3D;PART_KEY_OS_NAME</span><br><span class="line">1800 00000006 6950686f6e65 &#x2F;&#x2F;0x18&#x3D;24&#x3D;PART_KEY_CLIENT_MODEL</span><br></pre></td></tr></table></figure><p>(完)<br>(原创文章，转载请注明出处)</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;FridaNSLogger&quot;&gt;&lt;a href=&quot;#FridaNSLogger&quot; class=&quot;headerlink&quot; title=&quot;FridaNSLogger&quot;&gt;&lt;/a&gt;FridaNSLogger&lt;/h2&gt;&lt;p&gt;FridaNSLogger可以在Frida中将日志信息通过socket连接发送至Mac端查看。&lt;br&gt;Mac端日志查看工具 &lt;code&gt;FridaNSLoggerViewer&lt;/code&gt; 基于 &lt;a href=&quot;https://github.com/fpillet/NSLogger&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;NSLogger&lt;/a&gt; 修改实现。&lt;br&gt;项目地址 &lt;a href=&quot;https://github.com/neil-wu/FridaNSLogger&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/neil-wu/FridaNSLogger&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="技术" scheme="https://neil-wu.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS逆向" scheme="https://neil-wu.github.io/tags/iOS%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>B站直播间特效表情文件的获取</title>
    <link href="https://neil-wu.github.io/2020/01/02/2020-01-02-bili-svga/"/>
    <id>https://neil-wu.github.io/2020/01/02/2020-01-02-bili-svga/</id>
    <published>2020-01-01T16:00:00.000Z</published>
    <updated>2020-04-01T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>小破站今年的跨年晚会很是不错，在跨年夜总算给本阿宅一点点精神慰藉。在用手机看直播的时候，大家刷的礼物特效不停出现，我比较钟爱其中的“打call”，想着加到聊天软件里做个表情，以后兄弟们分享文章的时候可以商业互吹一番。搜了一圈没有发现现成的，今天空下来，随即手撸了一下找到表情文件，简单记录一下过程。</p><a id="more"></a> <h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>老套路，越狱iPhone，AppStore里下载B站客户端，打开<code>FLEXible</code>开关，搬出<code>FLEX</code>看看这个特效表情是个啥子东西。设置好后，进入客户端，在首页找到<code>直播</code>入口，然后里面选个人气高的直播间进去，耗费巨资手刷一个打call表情，待显示时候，查看FLEX的Views结构如下：</p><figure>    <img src="/images/article/bilisvga/b1.jpg" style="width:300px;"/></figure><p>可疑的类为 <code>BBLiveBaseSVGAAnimationView</code> 和 <code>SVGAPlayer</code>， 我们知道SVG是可以作为矢量图像的，点进去看一下，发现里面有个<code>SVGAVideoEntity</code>，进一步查看，确认这个就是表情文件了，里面的images字典就是是图片帧各个部分的元素的碎图。</p><figure>    <img src="/images/article/bilisvga/b2.jpg" style="width:300px;"/></figure><p>到此，我们定位到了特效文件的显示对象。</p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>按惯例，先广撒网一下，Google一下<code>SVGAPlayer</code>，居然有意外收获: <a href="https://github.com/yyued/SVGAPlayer-iOS" target="_blank" rel="noopener">SVGAPlayer</a> 是YY的UED团队出品的一个特效方案，类似于airbnb的Lottie，可以将AE或Flash动画导出到客户端所用。网站<a href="http://svga.io/" target="_blank" rel="noopener">http://svga.io/</a>中有详细介绍，并且含有一个svga文件的<a href="http://svga.io/svga-preview.html" target="_blank" rel="noopener">在线预览页面</a>。</p><p>根据其iOS端使用手册，验证 <code>SVGAParser</code>类 确实也在B站客户端中有引用，hook一下它的几个parseWith函数，运行后顺利拿到初始化特效文件的日志：</p><p><code>SVGAParser parseWithData, &lt;789c4cba 05505c5b d3358cbb bbbb0577 ... b6d054d7 e309d1ff 01424fd4 86&gt;, cacheKey 14EAD217D8A29CA4B7320F1CCF549584</code></p><p>789c4cba开头的应该为动画的Data数据，数据有点大，这里截断显示了。</p><p>根据cacheKey在app的存储目录下搜索一番，<code>find . -name &quot;*14EAD217D8A29CA4B7320F1CCF549584*&quot;</code> 无结果，说明没这个文件，不用灰心，换grep再撸一遍，<code>grep -rn &quot;14EAD217D8A29CA4B7320F1CCF549584&quot; ./</code>，这次有意外收获：<br>(多余的目录前缀已删掉)</p><p><code>Binary file ./Library/Caches/live/animation/manifest.sqlite-wal matches</code></p><p>匹配了两个sqlite的wal文件。顺带说一嘴这个是什么？WAL是 <code>Write-Ahead Logging</code>的意思，是实现原子提交和回滚的一种机制。<a href="https://www.sqlite.org/wal.html" target="_blank" rel="noopener">How WAL Works</a>。</p><p>检查一下<code>animation</code>文件夹下还有什么？ <code>data manifest.sqlite manifest.sqlite-shm manifest.sqlite-wal trash</code>，在data文件夹下找到一堆类似md5命名的文件，大小为几百K，拷贝到Mac上 file一下：</p><p><code>file ./Library/Caches/live/animation/data/b84008c716944e598887d43b3ff89514</code><br><code>./Library/Caches/live/animation/data/b84008c716944e598887d43b3ff89514: Apple binary property list</code></p><p>很显然了，是plist文件。改后缀名为plist后打开查看：</p><figure>    <img src="/images/article/bilisvga/b3.png" /></figure><p>将数据部分提取出来保存为文件：<br><code>/usr/libexec/PlistBuddy -c &#39;Print :&quot;$objects:1&quot;&#39; b84008c716944e598887d43b3ff89514.plist  &gt; 1.svga</code></p><p>用svga文件<a href="http://svga.io/svga-preview.html" target="_blank" rel="noopener">在线预览工具</a> 打开刚才保存的 1.svga，播放成功。</p><p>吼，剩下的就是跑shell脚本从这些plist文件中提取一下svga的过程了，最后，终于找到了心爱的打call表情，最后的最后，无奈录屏转为GIF了…</p><p><a href="https://github.com/neil-wu/BiliAnimation" target="_blank" rel="noopener">提取的一些svga文件记录</a></p><p>(完)<br>(原创文章，转载请注明出处)</p><figure>    <img src="/images/article/bilisvga/b4.png" style="width:300px;"/></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;小破站今年的跨年晚会很是不错，在跨年夜总算给本阿宅一点点精神慰藉。在用手机看直播的时候，大家刷的礼物特效不停出现，我比较钟爱其中的“打call”，想着加到聊天软件里做个表情，以后兄弟们分享文章的时候可以商业互吹一番。搜了一圈没有发现现成的，今天空下来，随即手撸了一下找到表情文件，简单记录一下过程。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="技术" scheme="https://neil-wu.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS逆向" scheme="https://neil-wu.github.io/tags/iOS%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS Unity3D 游戏修改实战</title>
    <link href="https://neil-wu.github.io/2018/01/19/2018-01-19-iOS-Unity-frog/"/>
    <id>https://neil-wu.github.io/2018/01/19/2018-01-19-iOS-Unity-frog/</id>
    <published>2018-01-18T16:00:00.000Z</published>
    <updated>2020-04-04T12:34:16.200Z</updated>
    
    <content type="html"><![CDATA[<p>iOS Unity3D 游戏修改实战</p><p>最近玩了一个叫 旅行青蛙 的手机游戏，主人公大佬是一只可爱的蛤，最爱的就是去西方各个国家旅行，旅行过程中会寄送明信片回来。玩家要通过收取三叶草来买道具给蛤用，越好的道具越可能得到稀有明信片。三叶草每隔一段时间会重新长出。</p><p>本文从加速游戏时间和修改三叶草数值 这两方面来进行说明，提供两种修改方法。用到的工具和相关说明在 <a href="https://github.com/neil-wu/iOSUnityGameMod_frog" target="_blank" rel="noopener">项目iOSUnityGameMod_frog</a></p><a id="more"></a>  <h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>在越狱设备上手动脱壳一份IPA安装包； THEOS开发环境；Hopper。 在此不再赘述。</p><h3 id="加速游戏时间"><a href="#加速游戏时间" class="headerlink" title="加速游戏时间"></a>加速游戏时间</h3><p>加速游戏时间可通过Hook系统时间函数，将返回的时间往后累计修改。经测试，Hook gettimeofday 有效，设计实现如下。启动时加载上次记录的时间点<code>gStartTimestamp</code>，然后在gettimeofday里，将返回的结果以此时间点往后累计，这样在正常游戏的时候并不改变帧率，如果需要改变，则将此时间间隔<code>addSeconds</code>调快。另外，在 <code>applicationDidEnterBackground</code>中，每次切入后台后将 <code>gStartTimestamp</code> 往后调 2小时，则下次切回游戏时，会使用该新时间，三叶草一般可以收割了，如果想加快蛤回家，多切几次后台回来即可。</p><h3 id="修改三叶草数量"><a href="#修改三叶草数量" class="headerlink" title="修改三叶草数量"></a>修改三叶草数量</h3><p>使用Hopper分析64位可执行程序发现，里面做了符号剔除，除了一个广告SDK外，并没有太多有价值的信息。被剔除符号表后，函数大部分是以sub_XXXX的形式的C函数。不要着急，查看二进制文件中的字符串信息，发现是以Unity3D引擎编写的程序，应该是使用 IL2CP 选项来编译的C代码。</p><p><a href="https://docs.unity3d.com/Manual/IL2CPP.html" target="_blank" rel="noopener">关于IL2CPP的介绍</a></p><p>直接分析可执行文件难度较大，不过，以此方式编译的代码，游戏逻辑使用的字符串都保存在 <code>Data/Managed/Metadata/global-metadata.dat</code> 中，将IPA包解压开，找到该文件，这时候，搬出我们的大杀器 <a href="https://github.com/Perfare/Il2CppDumper" target="_blank" rel="noopener">Il2CppDumper</a>， 找个win机器，运行 Il2CppDumper， 先选择二进制可执行程序，然后选择 global-metadata.dat，平台选择 64bit, 模式选择Auto，运行结束，会生成dump.cs和script.py两个文件和一个DummyDll文件夹，这里，先打开生成的 <code>dump.cs</code>，这样，里面是游戏所有C#头文件信息。</p><p>先大概浏览一下，我们的目标是修改三叶草的数量， 秉着大胆假设小心求证的理念，在里面搜索关键词 <code>Frog</code> 即青蛙，发现有如下定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class ObjectMaster_MainOut : ObjectMaster // TypeDefIndex: 2392</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Fields</span></span><br><span class="line">    <span class="keyword">public</span> GameObject CloverFarm; <span class="comment">// 0x20</span></span><br><span class="line">    <span class="keyword">public</span> GameObject Post; <span class="comment">// 0x28</span></span><br><span class="line">    <span class="keyword">public</span> GameObject Table; <span class="comment">// 0x30</span></span><br><span class="line">    <span class="keyword">public</span> GameObject Door; <span class="comment">// 0x38</span></span><br><span class="line">    <span class="keyword">public</span> GameObject Frog; <span class="comment">// 0x40</span></span><br><span class="line">    <span class="keyword">public</span> GameObject frontBackMain; <span class="comment">// 0x48</span></span><br></pre></td></tr></table></figure><p>可以判定，三叶草在代码里的命名为 <code>Clover</code>，以此为关键词继续搜索，发现 <code>类SuperGameMaster</code> 的 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getCloverPoint</span><span class="params">(<span class="keyword">int</span> num)</span></span>; <span class="comment">// 0x1000938BC</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">CloverPointStock</span><span class="params">()</span></span>; <span class="comment">// 0x100093A2C</span></span><br></pre></td></tr></table></figure><p>比较可疑，从字面意思和函数参数返回值看 CloverPointStock 应该是获取库存的三叶草数量，getCloverPoint 应该是更新设置三叶草数量(这里难道不该命名为 setCloverPoint ？？？)。 Il2CppDumper dump出来的头文件后面跟的二进制数字注释，就是该函数在IDA/Hopper中的位置。 </p><p>到这里，直接打开Hopper，跳转到 CloverPointStock 的位置 <code>0x100093A2C</code>，直接修改汇编代码，将该函数的返回值修改掉，<br>arm64里面 int 类型的函数返回值存在 w0 寄存器，这里直接修改w0寄存器的值然后让函数返回。<br>选择菜单 <code>Modify - Assembel Instruction</code>, 先输入 <code>mov w0, #0xffff</code>, 然后点击弹窗的 <code>Assemble and Go Next</code>, 再输入 <code>ret</code></p><p><img src="https://raw.githubusercontent.com/neil-wu/iOSUnityGameMod_frog/master/Hopper.jpg" alt="截图"></p><p>然后先保存文件，再选择菜单 <code>File - Produce New Executable</code>, 生成新的可执行文件。</p><h3 id="打包新IPA"><a href="#打包新IPA" class="headerlink" title="打包新IPA"></a>打包新IPA</h3><p>在第二步中，我们是在越狱环境下进行的测试，Tweak会生成一个 dylib动态库，想要在非越狱环境下运行，需要重新打包新的IPA并签名。 </p><p>假定 xxxx.dylib是越狱环境下的Tweak动态库文件，先使用 install_name_tool 修改一下库依赖， </p><p><code>install_name_tool -change /Library/Frameworks/CydiaSubstrate.framework/CydiaSubstrate @executable_path/libsubstrate.dylib xxxx.dylib</code></p><p>libsubstrate.dylib 为非越狱环境下使用的substrate库。 将 xxxx.dylib libsubstrate.dylib 和 第三步生成的新文件覆盖到原包中，并将 xxxx.dylib 注入到可执行程序中 <code>yololib tabikaeru testfrog.dylib</code></p><p>打包为IPA-签名-安装。</p><p>(完)<br>(原创文章，转载请注明出处)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;iOS Unity3D 游戏修改实战&lt;/p&gt;
&lt;p&gt;最近玩了一个叫 旅行青蛙 的手机游戏，主人公大佬是一只可爱的蛤，最爱的就是去西方各个国家旅行，旅行过程中会寄送明信片回来。玩家要通过收取三叶草来买道具给蛤用，越好的道具越可能得到稀有明信片。三叶草每隔一段时间会重新长出。&lt;/p&gt;
&lt;p&gt;本文从加速游戏时间和修改三叶草数值 这两方面来进行说明，提供两种修改方法。用到的工具和相关说明在 &lt;a href=&quot;https://github.com/neil-wu/iOSUnityGameMod_frog&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目iOSUnityGameMod_frog&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="技术" scheme="https://neil-wu.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS逆向" scheme="https://neil-wu.github.io/tags/iOS%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>iOS下基于 theos-jailed 的非越狱环境Hook快速开发工作流</title>
    <link href="https://neil-wu.github.io/2017/07/13/2017-07-13-JailedTweakWorkflow/"/>
    <id>https://neil-wu.github.io/2017/07/13/2017-07-13-JailedTweakWorkflow/</id>
    <published>2017-07-12T16:00:00.000Z</published>
    <updated>2020-04-04T12:34:16.200Z</updated>
    
    <content type="html"><![CDATA[<p>基于 <a href="https://github.com/BishopFox/theos-jailed" target="_blank" rel="noopener">theos-jailed</a> 的非越狱环境Hook快速开发工作流</p><p>前段时间看到 <a href="https://github.com/yulingtianxia/FishChat" target="_blank" rel="noopener">FishChat</a> 这个项目，是在非越狱环境下进行Hook，项目本身用到了CaptainHook来进行开发。<br>了解过越狱环境开发的同学一定用过Logos来写Tweak，那么如果这个项目采用Logos来进行开发，项目代码可能更易读一些。 正好有 <a href="https://github.com/BishopFox/theos-jailed" target="_blank" rel="noopener">theos-jailed</a> 这个项目，可以将Tweak应用到非越狱环境下。 本项目从FishChat中选取一个小功能：<code>修改步数</code>，来做个示范，怎么来达到这个目的。</p><a id="more"></a>  <p><a href="https://github.com/neil-wu/JailedTweakWorkflow" target="_blank" rel="noopener">项目工程在此处</a></p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>安装 (theos)[<a href="http://iphonedevwiki.net/index.php/Theos/Setup]" target="_blank" rel="noopener">http://iphonedevwiki.net/index.php/Theos/Setup]</a> 和 (theos-jailed)[<a href="https://github.com/BishopFox/theos-jailed]" target="_blank" rel="noopener">https://github.com/BishopFox/theos-jailed]</a><br>其中，前者用于越狱环境开发的工具；后者用于将前者代码打包部署到非越狱环境的工具。 </p></li><li><p>使用 <code>theos 的 nic.pl</code> 创建 <code>iphone/tweak</code> 工程， 命名 <code>jailbrokentweak</code></p></li><li><p>使用 <code>theos-jailed 的 nic.pl</code> 创建 <code>iphone/tweak</code> 工程， 命名 <code>jailedtweak</code></p></li></ol><h3 id="开始处理-jailbrokentweak"><a href="#开始处理-jailbrokentweak" class="headerlink" title="开始处理 jailbrokentweak"></a>开始处理 jailbrokentweak</h3><p>不熟悉Logos语法的同学可以先从 <a href="http://iphonedevwiki.net/index.php/Logos" target="_blank" rel="noopener">此页面</a> 了解一下。</p><p>通过阅读FishChat的源代码我们知道，需要实现修改步数的功能，要<code>Hook WCDeviceStepObject</code> 的 <code>- (unsigned int)m7StepCount</code> ，此外，参考FishChat的实现，还需要实现一个输入步数的功能即可。 具体实现参考代码。</p><p>需要注意的点： </p><ol><li><p><code>jailbrokentweak</code> 的 <code>Makefile</code> 里 添加了 <code>THEOS_DEVICE_IP = 127.0.0.1 -p 2229</code>， 是使用 <code>usbmuxd</code> 讲设备端口映射了一下</p></li><li><p><code>JailbrokenTweak_FILES = $(wildcard ./*.xm)</code> 来匹配当前目录下的所有xm文件</p></li></ol><h3 id="开始处理-jailedtweak"><a href="#开始处理-jailedtweak" class="headerlink" title="开始处理 jailedtweak"></a>开始处理 jailedtweak</h3><p>在上一步越狱环境下 <code>jailbrokentwea</code> 工程测试OK后，将 <code>*.h *.xm</code> 文件拷贝到 <code>jailedtwea</code>k 下，对应修改 <code>Makefile</code> 。 我的测试工程 <code>jailedtweak</code> 中删除了没有用到的文件。 </p><p>准备好文件后，make编译一下，如果遇到错误 <code>library not found for -ldylib1.o</code>，请下载 <code>xcode7</code>, 然后使用 <code>xcode-select</code>设置使用xcode7, 比如我的设置 <code>sudo xcode-select -s /Applications/Xcode731.app/Contents/Developer/</code></p><p>编译成功后，找到 <code>obj/JailedTweak.dylib</code> 文件，让我们看看发生了什么变化，<code>otool -L obj/JailedTweak.dylib</code>，可以看到，它将 <code>CydiaSubstrate</code>的依赖自动加上了 <code>@executable_path/CydiaSubstrate</code>，所以我们在最终打包的时候也需要拷贝 <code>CydiaSubstrate</code>，那么它在哪？ 其实就在 <code>jailedtweak/PatchApp/</code> 中</p><h3 id="打包签名"><a href="#打包签名" class="headerlink" title="打包签名"></a>打包签名</h3><p><code>jailedtweak</code> make 完成后，会调用其中的 <code>patchapp.sh</code>来自动尝试打包，不过不太好用，可以自己通过签名脚本实现，注意的是需要拷贝 <code>JailedTweak.dylib 和 CydiaSubstrate</code> 两个文件到包中，然后使用 <code>yololib</code> 注入 <code>JailedTweak.dylib</code> (只需注入该文件即可)。</p><p>安装运行 :-)</p><p>(完)<br>(原创文章，转载请注明出处)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于 &lt;a href=&quot;https://github.com/BishopFox/theos-jailed&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;theos-jailed&lt;/a&gt; 的非越狱环境Hook快速开发工作流&lt;/p&gt;
&lt;p&gt;前段时间看到 &lt;a href=&quot;https://github.com/yulingtianxia/FishChat&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FishChat&lt;/a&gt; 这个项目，是在非越狱环境下进行Hook，项目本身用到了CaptainHook来进行开发。&lt;br&gt;了解过越狱环境开发的同学一定用过Logos来写Tweak，那么如果这个项目采用Logos来进行开发，项目代码可能更易读一些。 正好有 &lt;a href=&quot;https://github.com/BishopFox/theos-jailed&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;theos-jailed&lt;/a&gt; 这个项目，可以将Tweak应用到非越狱环境下。 本项目从FishChat中选取一个小功能：&lt;code&gt;修改步数&lt;/code&gt;，来做个示范，怎么来达到这个目的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="技术" scheme="https://neil-wu.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS逆向" scheme="https://neil-wu.github.io/tags/iOS%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>如何使用iTunes下载App Store旧版iOS app</title>
    <link href="https://neil-wu.github.io/2016/02/14/2016-02-14-iOS-App-Rollback/"/>
    <id>https://neil-wu.github.io/2016/02/14/2016-02-14-iOS-App-Rollback/</id>
    <published>2016-02-13T16:00:00.000Z</published>
    <updated>2020-04-04T12:34:16.200Z</updated>
    
    <content type="html"><![CDATA[<p>旧版本iOS app下载方法</p><p><a href="https://hiraku.tw/2015/12/4140/" target="_blank" rel="noopener">(English Version Here) How to download legacy versions of iOS apps</a></p><a id="more"></a>  <h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>1、本教程需要一定的技术、耐心及英语水平，请结合自身情况后考虑是否尝试</p><p>2、教程针对Windows系统，Mac也可通过类似步骤成功</p><p>3、文中使用 Fiddler 为抓包工具，如有自己熟悉的抓包工具也可换用</p><p>4、由于抓包代理的特殊性，不建议下载过大App（300M以上），容易卡（也没有其他什么影响，就是会卡）</p><p>5、演示使用版本：iTunes 12.3.1.23，Fiddler 2.6.0.5</p><p><a href="biliplus.com/itunes_rollback.htm">视频演示地址</a></p><p>以下为操作步骤：</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>1、没装iTunes和不会用iTunes的App Store的先去补习</p><p>2、<a href="www.telerik.com/download/fiddler">下载Fiddler</a>，Win8以上用户建议Fiddler for .NET4（其实两个版本没啥大区别，就是Win8自带.NET4）</p><figure>    <a href="/images/article/ipa_rollback/1.png"><img src="/images/article/ipa_rollback/1.png"></a></figure><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>本文以下载QQ 5.9.1版为例：</p><p>1、打开<code>Fiddler</code>，选择菜单栏<code>Tools-Fiddler Options</code>，HTTPS选项卡，勾选<code>Decrypt HTTPS traffic</code>，弹出窗口点<code>Yes</code>，新弹出安装证书窗口选择“是”</p><p>【注意不要关闭Fiddler】</p><p>【安装证书失败或打开iTunes无法加载页面请至底部】</p><figure>    <a href="/images/article/ipa_rollback/2.png"><img src="/images/article/ipa_rollback/2.png"></a></figure><p>2、打开iTunes（如之前已打开请关闭iTunes重新打开），搜索想下载的App（本文以下载QQ 5.9.1版为例）</p><p>3、点击下载，等右上角出现箭头后删除下载（选中下载按两次delete）</p><figure>    <a href="/images/article/ipa_rollback/3.png"><img src="/images/article/ipa_rollback/3.png"></a></figure><p>4、返回Fiddler将还在下载的项目删除（仅为了节省网速）</p><figure>    <a href="/images/article/ipa_rollback/4.png"><img src="/images/article/ipa_rollback/4.png"></a></figure><p>5、在该删除的下载项上方找到域名为 <code>p32-buy.itunes.apple.com</code>，url开头为<code>/WebObjects/MZBuy.woa</code>的请求，切换右侧至<code>Inspectors</code>选项卡，并点击中间的黄色块<code>(Response is encoded and may require decoding before inspection. Click here to transform.)</code><br>（编辑：域名可能不同，重点在于找到<code>/WebObjects/MZBuy.woa</code>）</p><figure>    <a href="/images/article/ipa_rollback/5.png"><img src="/images/article/ipa_rollback/5.png"></a></figure><p>6、保存该请求（右键请求-Save-Response-Response Body）【注意如果没有点黄色方块将会保存一个乱码文件】</p><p>7、打开保存的xml文件（系统默认一般是IE打开），向下翻动找到softwareVersionExternalIdentifiers并伴随着一大串“<integer>xxxxxxxxxx</integer>”的项目</p><p>【说明：此处为该App自第一个版本起每个版本在app store中的版本id，从后向前即为最新到最老】</p><p>【另，iOS9开始的App Thining会导致同一个app版本有多个版本id，具体差异我没有试，如果安装出现问题可以换一个版本id试】</p><figure>    <a href="/images/article/ipa_rollback/6.png"><img src="/images/article/ipa_rollback/6.png"></a></figure><p>8、回到Fiddler，右键之前那个<code>MZBuy</code>的请求，<code>Replay-Reissue and Edit</code>，编辑右侧上方<code>appExtVrsId</code>下方数字为对应版本id（此处直接使用QQ 5.9.1版本id 813463229），点击绿色按钮，切换至黄色块下方最右侧”XML”视图，下拉至图中位置查看app版本，不断重复本步骤直至找到需要下载的版本【期间如果无法正常获取即为请求已经过期，重新执行3-4步然后使用新的请求进行编辑重发操作】</p><figure>    <a href="/images/article/ipa_rollback/7.png"><img src="/images/article/ipa_rollback/7.png"></a></figure><figure>    <a href="/images/article/ipa_rollback/8.png"><img src="/images/article/ipa_rollback/8.png"></a></figure><figure>    <a href="/images/article/ipa_rollback/9.png"><img src="/images/article/ipa_rollback/9.png"></a></figure><p>9、确认需要下载的版本id后，先在iTunes中重新进行一次搜索或点进app详情页（使“正在下载”按钮恢复），然后开启拦截模式<code>【菜单栏Rules-Automatic Breakpoints-Before Requests】</code>，然后返回iTunes点击下载。回到Fiddler里面应该会有几个红色图标的请求，同样，找到<code>MZBuy.woa</code>（如果是Tunnel to先直接点绿色按钮放行），右侧编辑版本id为需要下载的版本id【不是Replay编辑】，然后关闭拦截模式<code>【菜单栏Rules-Automatic Breakpoints-Disabled】</code>，点击绿色按钮发送请求</p><p><code>（梳理步骤：开启拦截-&gt;点下载-&gt;如果有Tunnel To放行后等带内容的请求出现-&gt;关闭拦截-&gt;编辑请求并发送）</code></p><figure>    <a href="/images/article/ipa_rollback/10.png"><img src="/images/article/ipa_rollback/10.png"></a></figure><p>其他红色的请求也可以一并放行，也可不管，这都不重要）</p><p>10、您点的旧版本App已经开始下载啦</p><figure>    <a href="/images/article/ipa_rollback/11.png"><img src="/images/article/ipa_rollback/11.png"></a></figure><p><code>（下载过程中需要保持Fiddler和iTunes一同打开，不可关闭）</code></p><p>接下来该干啥干啥，爱用哪个助手就用哪个助手安装就可以啦</p><h3 id="补充：Fiddler根证书补安装"><a href="#补充：Fiddler根证书补安装" class="headerlink" title="补充：Fiddler根证书补安装"></a>补充：Fiddler根证书补安装</h3><p>1、Fiddler菜单栏Tools-Fiddler Options，HTTPS选项卡</p><p>2、下方的Export Root Certificate to Desktop【151221更新：更新Fiddler到2.6.1.5后发现按钮换位置了，右侧Action-Export Root Certificate to Desktop】</p><p>3、桌面上会有一个“FiddlerRoot.cer”文件，右键安装证书</p><p>4、在第二步中安装证书位置选择第二个并点击“浏览”</p><p>5、选择“信任的根证书存储”(Trusted Root Certification Authorities)（我用的英文系统不太记得官方翻译，大概就这个意思）</p><p>6、一路下一步</p><p><a href="http://bbs.feng.com/forum.php?mod=viewthread&tid=10125110&page=1#pid156307133" target="_blank" rel="noopener">原帖</a></p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;旧版本iOS app下载方法&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hiraku.tw/2015/12/4140/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;(English Version Here) How to download legacy versions of iOS apps&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="技术" scheme="https://neil-wu.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="教程" scheme="https://neil-wu.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>关于AutoLayout中的margin</title>
    <link href="https://neil-wu.github.io/2015/09/04/2015-10-30-AutoLayout-Margins/"/>
    <id>https://neil-wu.github.io/2015/09/04/2015-10-30-AutoLayout-Margins/</id>
    <published>2015-09-03T16:00:00.000Z</published>
    <updated>2020-04-04T12:34:16.200Z</updated>
    
    <content type="html"><![CDATA[<p>在做UI适配的时候，发现个别view定义的leading和trailling margin在iPhone 6 plus下会有一点间隙（4pt），其他则正常，记录一下这个问题的原因。</p><a id="more"></a> <h3 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述：###"></a>问题描述：###</h3><p>在IB里向一个空的ViewController中添加一个UIView对象，拖动左右边界对齐父视图，如下图：</p><figure>    <a href="/images/article/autolayout/autolayout-margin-1.png"><img src="/images/article/autolayout/autolayout-margin-1.png"></a></figure><p>添加leading and trailing space约束，（同时添加个居中约束，高度约束，）如下图：</p><figure>    <a href="/images/article/autolayout/autolayout-margin-2.png"><img src="/images/article/autolayout/autolayout-margin-2.png"></a></figure><p>可以看到结果如下：</p><figure>    <a href="/images/article/autolayout/autolayout-margin-3.png"><img src="/images/article/autolayout/autolayout-margin-3.png"></a></figure><p>可以看到IB设置的约束值为-16，(如果在这里将其改为0，IB会提示该View需要更新size，更新后在IB里会看到左右边距)。</p><p>使用-16的约束值，运行，在iPhone5s下表现正常，如下图：</p><figure>    <a href="/images/article/autolayout/autolayout-margin-4.png"><img src="/images/article/autolayout/autolayout-margin-4.png"></a></figure><p>iPhone 6 plus的运行结果如下图，可以看到左右的边距：</p><figure>    <a href="/images/article/autolayout/autolayout-margin-5.png"><img src="/images/article/autolayout/autolayout-margin-5.png"></a></figure><h3 id="为什么同样的约束，在plus下会出现这样的结果呢？因为layoutMargins"><a href="#为什么同样的约束，在plus下会出现这样的结果呢？因为layoutMargins" class="headerlink" title="为什么同样的约束，在plus下会出现这样的结果呢？因为layoutMargins"></a>为什么同样的约束，在plus下会出现这样的结果呢？因为<code>layoutMargins</code></h3><h3 id="关于layoutMargins"><a href="#关于layoutMargins" class="headerlink" title="关于layoutMargins"></a>关于layoutMargins</h3><p>iOS8后，UIView 有个属性 <code>var layoutMargins: UIEdgeInsets</code>,用来指定该View的subview同其edge的间距。AutoLayout使用margins来放置内容。<br>默认的值为8pt。</p><p>如果一个View是ViewController的rootview，系统会自动设置和管理margins，top和bottom margins被设置为0pt，left和right的值根据当前的<code>size class</code>（文末简单介绍一下size class）不同而不同，可能取值为16或者20pt(iPhone6 plus, iPad)，你不能修改这些值。</p><p>所以，你知道iPhone 6 plus下那个4pt的间隙是怎么来的了吧。</p><p>当在一个空的ViewController里添加一个新UIView时，我们通过拖拽添加的约束会提示为类似：<code>Leading Space To Contrainer Margin</code>。而往一个UIView添加新的View，然后对其设置约束，会提示：<code>Leading Space To Contrainer</code>（这时候是到edge）。</p><p>如果想要将<code>Leading Space To Contrainer Margin</code>设置为edge对齐，可以这样操作：双击编辑该约束，如下图所示，取消掉 <code>Relative to margin</code></p><figure>    <a href="/images/article/autolayout/autolayout-margin-6.png"><img src="/images/article/autolayout/autolayout-margin-6.png"></a></figure><p>参考Apple的文档:  <a href="https://developer.apple.com/library/ios/recipes/xcode_help-IB_auto_layout/chapters/EditingConstraintAttributesintheAttributesInspector.html" target="_blank" rel="noopener">Editing Auto Layout Constraints</a></p><p>附录：size class 简单说明</p><p>Size Class 的作用是将不同尺寸的屏幕进行分类处理。对于宽度和高度而言，都有三种情况：紧凑 (Compact) 、任意 (Any) 、 正常 (Regular) ，所以一共有9个类别.</p><p>参考说明： <a href="http://onevcat.com/2014/07/ios-ui-unique/" target="_blank" rel="noopener">Size Classes</a></p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在做UI适配的时候，发现个别view定义的leading和trailling margin在iPhone 6 plus下会有一点间隙（4pt），其他则正常，记录一下这个问题的原因。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="技术" scheme="https://neil-wu.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="前端" scheme="https://neil-wu.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="iOS" scheme="https://neil-wu.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>Swift中的weak和unowned reference</title>
    <link href="https://neil-wu.github.io/2015/09/04/2015-09-04-Swift-weak-unowned/"/>
    <id>https://neil-wu.github.io/2015/09/04/2015-09-04-Swift-weak-unowned/</id>
    <published>2015-09-03T16:00:00.000Z</published>
    <updated>2020-04-04T12:34:16.200Z</updated>
    
    <content type="html"><![CDATA[<p>Swift是使用ARC来自动管理内存，这对开发者提供了便利，但从OC时代引入ARC以来，就一直面临着一个问题：循环引用。使用不当造成的循环引用，会导致内存无法释放，为解决这个问题，swift引入了weak和unowned两个关键字。当然，值类型是不涉及循环引用的问题，所以ARC仅仅应用于类的实例。</p><p>在编码时一般会出现两种情况的循环引用：1. 普通对象的循环强引用 2. 函数或闭包间的循环引用。 第一种情况相对比较容易发现，第二种情况更隐蔽，在使用的闭包时会无意间引入。</p><a id="more"></a> <h3 id="1-普通对象的循环强引用（比如设置delegate）"><a href="#1-普通对象的循环强引用（比如设置delegate）" class="headerlink" title="1. 普通对象的循环强引用（比如设置delegate）"></a>1. 普通对象的循环强引用（比如设置delegate）</h3><p>看以下代码片段：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span> = <span class="string">""</span></span><br><span class="line">    <span class="keyword">var</span> pet: <span class="type">Dog?</span> = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"People deinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> people: <span class="type">People?</span> = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">deinit</span> &#123;</span><br><span class="line">        <span class="built_in">println</span>(<span class="string">"Dog deinit"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> me = <span class="type">People</span>()</span><br><span class="line">me.name = <span class="string">"john"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pet = <span class="type">Dog</span>()</span><br><span class="line">pet.people = me</span><br><span class="line"></span><br><span class="line">me.pet = pet</span><br></pre></td></tr></table></figure><p>在Xcode项目中运行（Playground自身会持有变量，不能在其中做这个测试）。可以看到并没有任何一个deinit被执行，me和pet互相持有了对方，造成了循环引用。</p><p>如果我们在使用结束后，把me.pet=nil或者pet.people=nil，都会打破循环引用，各自对象均可以释放。但实际开发中这个置为nil的操作很容易遗漏，随着项目的复杂，排查难度会越来越大。</p><p>这种情况下，使用弱引用（ weak reference），声明为 <code>weak var people: People? = nil</code>,使之并不保持对所指对象的强持有，因此并不阻止ARC对引用实例的回收。这个特性保证了引用不成为强引用循环的一部分。</p><p>思考一下：这里可不可以修改为 <code>unowned var people: People? = nil</code> ??? （文末给出说明）</p><h3 id="2-函数或闭包间的循环引用"><a href="#2-函数或闭包间的循环引用" class="headerlink" title="2. 函数或闭包间的循环引用"></a>2. 函数或闭包间的循环引用</h3><p>看以下代码片段：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Alamofire</span>.request(.<span class="type">GET</span>,</span><br><span class="line">                  <span class="string">"http://httpbin.org/get"</span>,</span><br><span class="line">                  parameters: [<span class="string">"foo"</span>: <span class="string">"bar"</span>])</span><br><span class="line">         .response &#123; (request, response, data, error) <span class="keyword">in</span></span><br><span class="line">                     <span class="keyword">self</span>.doSomething()</span><br><span class="line">                   &#125;</span><br></pre></td></tr></table></figure><p>这里使用Alamofire的一个简单使用来做说明，我们使用Alamofire来向服务器发送请求，在响应中，调用当前ViewController实例的doSomething（更新UI啊，保存数据等操作）。一切看起来似乎很正常，当这个Viewcontroller被pop或者dismiss后，惊讶的发现其deinit函数没有执行。</p><p>由于Swift中的闭包是引用类型（也就是说，当定义一个函数(闭包)常量或变量时，实际上定义的是一个指向函数(闭包)的引用。这意味着如果指定一个闭包给两个不同的常量或变量，则这两个常量和变量将引用同一个函数(闭包)）。在以上代码执行时，该类的实例self生成了一个对response闭包的引用，而该闭包中，又引用了self实例，所以导致最后该实例没有释放。</p><p>解决方法是使用 捕获列表：<code>[unowned self]  (request, response, data, error) in</code> 。捕获列表中的每个元素都是由weak或者unowned关键字和实例的引用（如self）成对组成。每一对都在方括号中，通过逗号分开。</p><h3 id="如何选择使用weak或unowned"><a href="#如何选择使用weak或unowned" class="headerlink" title="如何选择使用weak或unowned"></a>如何选择使用weak或unowned</h3><p>回答上面提出的问题：不能使用<code>unowned var people: People? = nil</code></p><p>简单来说：被标记为 weak 的变量一定需要是optional 值, unowned 不能是optional。</p><p>Apple 给我们的建议是如果能够确定在访问时不会已被释放的话，尽量使用 unowned，如果存在被释放的可能，那就选择用 weak。weak友好一些，在引用的内容被释放后，标记为 weak 的成员将会自动地变成 nil。</p><p>在实例的生命周期中，如果某些时候引用没有值，那么弱引用可以阻止循环强引用。如果引用总是有值，则可以使用无主引用，在无主引用中有描述。<br>弱引用必须被声明为变量，表明其值能在运行时被修改，不能被声明为常量。</p><p>推荐阅读：</p><p><a href="http://swifter.tips/retain-cycle/" target="_blank" rel="noopener">内存管理，WEAK 和 UNOWNED</a></p><p><a href="http://southpeak.github.io/blog/2014/06/27/ios-swift-closures/" target="_blank" rel="noopener">Swift闭包一：闭包基础概念</a></p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Swift是使用ARC来自动管理内存，这对开发者提供了便利，但从OC时代引入ARC以来，就一直面临着一个问题：循环引用。使用不当造成的循环引用，会导致内存无法释放，为解决这个问题，swift引入了weak和unowned两个关键字。当然，值类型是不涉及循环引用的问题，所以ARC仅仅应用于类的实例。&lt;/p&gt;
&lt;p&gt;在编码时一般会出现两种情况的循环引用：1. 普通对象的循环强引用 2. 函数或闭包间的循环引用。 第一种情况相对比较容易发现，第二种情况更隐蔽，在使用的闭包时会无意间引入。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="技术" scheme="https://neil-wu.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="前端" scheme="https://neil-wu.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="iOS" scheme="https://neil-wu.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>SDWebImage中使用FLAnimatedImage来播放gif</title>
    <link href="https://neil-wu.github.io/2015/08/08/2015-08-08-SDWebImage-with-FLAnimatedImage/"/>
    <id>https://neil-wu.github.io/2015/08/08/2015-08-08-SDWebImage-with-FLAnimatedImage/</id>
    <published>2015-08-07T16:00:00.000Z</published>
    <updated>2020-04-04T12:34:16.200Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/rs/SDWebImage" target="_blank" rel="noopener">SDWebImage</a> 对gif图片的支持不是非常好，我们可以在其项目的讨论区看到大家的吐槽( <a href="https://github.com/rs/SDWebImage/issues/945" target="_blank" rel="noopener">Drop our GIF support and integrate a 3rd party solution #945</a>)。我简单修改了几处源码，使用 <a href="https://github.com/Flipboard/FLAnimatedImage" target="_blank" rel="noopener">FLAnimatedImage</a>来显示gif图片。SDWebImage 仍用作默认的图片加载和缓存，只是在需要显示gif图片时，改用FLAnimatedImage。</p><a id="more"></a> <p>对源码的修改和如何使用，看这个 <a href="https://github.com/neil-wu/SDImageCacheWithGifDemo" target="_blank" rel="noopener">Demo</a></p><p>操作步骤：</p><h3 id="1-屏蔽SDWebImage显示gif图片的代码"><a href="#1-屏蔽SDWebImage显示gif图片的代码" class="headerlink" title="1. 屏蔽SDWebImage显示gif图片的代码"></a>1. 屏蔽SDWebImage显示gif图片的代码</h3><p>修改文件 <code>UIImage+MultiFormat.m</code>的第22-26行代码(行数可能有误差)，注释掉这部分代码，如下：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ (<span class="type">UIImage</span> *)sd_imageWithData:(<span class="type">NSData</span> *)data &#123;</span><br><span class="line">    <span class="type">UIImage</span> *image;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    //注释掉这里</span></span><br><span class="line"><span class="comment">    NSString *imageContentType = [NSData sd_contentTypeForImageData:data];</span></span><br><span class="line"><span class="comment">    if ([imageContentType isEqualToString:@"image/gif"]) &#123;</span></span><br><span class="line"><span class="comment">        image = [UIImage sd_animatedGIFWithData:data];</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span>) &#123; <span class="comment">//然后添加此if</span></span><br><span class="line">    &#125;</span><br><span class="line">#ifdef <span class="type">SD_WEBP</span></span><br></pre></td></tr></table></figure><h3 id="2-修改SDImageCache-h，将如下函数设为公有"><a href="#2-修改SDImageCache-h，将如下函数设为公有" class="headerlink" title="2. 修改SDImageCache.h，将如下函数设为公有"></a>2. 修改SDImageCache.h，将如下函数设为公有</h3><p>在SDImageCache.h里，添加<br><code>- (NSData *)diskImageDataBySearchingAllPathsForKey:(NSString *)key;</code> 声明。该函数已经实现，这里只是将其公有，以便我们能获取到gif图片数据，传给FLAnimatedImage来使用。</p><h3 id="3-显示图片时判断是否需要使用FLAnimatedImage"><a href="#3-显示图片时判断是否需要使用FLAnimatedImage" class="headerlink" title="3. 显示图片时判断是否需要使用FLAnimatedImage"></a>3. 显示图片时判断是否需要使用FLAnimatedImage</h3><p>直接看代码吧：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> imgurlstring.hasSuffix(<span class="string">".gif"</span>) &#123;</span><br><span class="line">    <span class="comment">//we use NSData from the cache</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="type">SDWebImageManager</span>.sharedManager().imageCache.diskImageDataBySearchingAllPathsForKey(imgurlstring)</span><br><span class="line">    <span class="keyword">var</span> img = <span class="type">FLAnimatedImage</span>(animatedGIFData: data!)</span><br><span class="line">    <span class="keyword">var</span> imgview = <span class="type">FLAnimatedImageView</span>(frame: <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.baseview.frame.width, <span class="keyword">self</span>.baseview.frame.height))</span><br><span class="line">    imgview.animatedImage = img</span><br><span class="line">    imgview.contentMode = <span class="type">UIViewContentMode</span>.<span class="type">ScaleAspectFit</span></span><br><span class="line">    <span class="keyword">self</span>.baseview.addSubview(imgview)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pngview = <span class="type">UIImageView</span>(image: image)</span><br><span class="line">    pngview.frame = <span class="type">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">self</span>.baseview.frame.width, <span class="keyword">self</span>.baseview.frame.height)</span><br><span class="line">    pngview.contentMode = <span class="type">UIViewContentMode</span>.<span class="type">ScaleAspectFit</span></span><br><span class="line">    <span class="keyword">self</span>.baseview.addSubview(pngview)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者直接下载这个 <a href="https://github.com/neil-wu/SDImageCacheWithGifDemo" target="_blank" rel="noopener">Demo</a> 来看效果。:]</p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/rs/SDWebImage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;SDWebImage&lt;/a&gt; 对gif图片的支持不是非常好，我们可以在其项目的讨论区看到大家的吐槽( &lt;a href=&quot;https://github.com/rs/SDWebImage/issues/945&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Drop our GIF support and integrate a 3rd party solution #945&lt;/a&gt;)。我简单修改了几处源码，使用 &lt;a href=&quot;https://github.com/Flipboard/FLAnimatedImage&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FLAnimatedImage&lt;/a&gt;来显示gif图片。SDWebImage 仍用作默认的图片加载和缓存，只是在需要显示gif图片时，改用FLAnimatedImage。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="技术" scheme="https://neil-wu.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="前端" scheme="https://neil-wu.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="iOS" scheme="https://neil-wu.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>使用xib来自定义UITableViewCell (Swift项目)</title>
    <link href="https://neil-wu.github.io/2015/07/21/2015-07-21-xib-table-view-cell/"/>
    <id>https://neil-wu.github.io/2015/07/21/2015-07-21-xib-table-view-cell/</id>
    <published>2015-07-20T16:00:00.000Z</published>
    <updated>2020-04-04T12:34:16.199Z</updated>
    
    <content type="html"><![CDATA[<p>之前在使用UITableView时，总是在Storeboard里直接把property cell放到相应ViewController的Table里。如果一个cell需要在其他ViewController里进行复用，我们可以直接在IB里进行复制，粘贴，这样虽然比较简单，但以后项目维护过程中，某个cell发生了改变，要重复该操作，且不能遗漏修改。可以在xib中设计cell来进行复用。</p><a id="more"></a> <p>操作步骤：</p><h3 id="1-新建一个empty-xib文件"><a href="#1-新建一个empty-xib文件" class="headerlink" title="1. 新建一个empty xib文件"></a>1. 新建一个empty xib文件</h3><p>File -&gt; New File -&gt; User Interface -&gt; <code>Empty</code></p><p>这里记得选用 Empty 来创建一个空的xib文件。</p><h3 id="2-在IB中设计cell"><a href="#2-在IB中设计cell" class="headerlink" title="2. 在IB中设计cell"></a>2. 在IB中设计cell</h3><p>打开刚才新建的xib文件（这里暂时命名为CellUI），拖入一个<code>Table View Cell</code>，自定义其size，然后根据需要设计该cell。</p><p>这个cell就是我们的自定义cell了。</p><h3 id="3-使用cell"><a href="#3-使用cell" class="headerlink" title="3. 使用cell"></a>3. 使用cell</h3><p>我们可以新建一个继承与UITableViewcell的类(TabLocationTableCell),将cell中的文本等元素与其关联。</p><p>在TableView的delegate里，我们自定义个resueID，修改cellForRowAtIndexPath</p><pre><code>override func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell {    var cell: AnyObject? = self.tableView.dequeueReusableCellWithIdentifier(self.resueCellID) //1    if nil == cell {        let viewList = NSBundle.mainBundle().loadNibNamed(&quot;CellUI&quot;, owner: self, options: nil) //2        for obj in viewList {            if obj is TabLocationTableCell {                cell = obj as? TabLocationTableCell //3                break            }        }    }    if let cell = cell as? TabLocationTableCell {        cell.nameTxt.text = self.jsonDataList![indexPath.row][&quot;GrpName&quot;].stringValue //4        return cell    }    println(&quot;never goes here&quot;) //5    return UITableViewCell()}</code></pre><p>代码说明：</p><ol><li>使用 <code>func dequeueReusableCellWithIdentifier(_ identifier: String) -&gt; AnyObject?</code> 来获取一个可用的cell。注意这里没有传入 <code>indexPath</code></li><li>如果没有可复用的cell，则加载xib，生成一个该cell</li><li>一个xib中可以放入多个view，从中找到我们需要的cell</li><li>可以对改cell内容进行赋值</li><li>程序应该永远运行不到这里，如果出现此信息，重新检查你的代码</li></ol><p>** 补充： **<br>采用这种方法时，不需要调用 <code>self.tableView.registerClass</code>。</p><p>以前在storyboard里直接设计cell时，我们都会使用<code>dequeueReusableCellWithIdentifier:forIndexPath:</code> 来获取可复用的cell，该方法才需要提前registerClass （IB里可以指定ID，会自动帮我们做）。否则，会收到错误：</p><p>Terminating app due to uncaught exception ‘NSInternalInconsistencyException’, reason: ‘unable to dequeue a cell with identifier locationCell - must register a nib or a class for the identifier or connect a prototype cell in a storyboard’</p><p>(完)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前在使用UITableView时，总是在Storeboard里直接把property cell放到相应ViewController的Table里。如果一个cell需要在其他ViewController里进行复用，我们可以直接在IB里进行复制，粘贴，这样虽然比较简单，但以后项目维护过程中，某个cell发生了改变，要重复该操作，且不能遗漏修改。可以在xib中设计cell来进行复用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="tech" scheme="https://neil-wu.github.io/categories/tech/"/>
    
    
      <category term="技术" scheme="https://neil-wu.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="前端" scheme="https://neil-wu.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="iOS" scheme="https://neil-wu.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
